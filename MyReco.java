// MyReco:

import java.io.*;

class MyReco {
	static final int BLACK = 0x00;
    static final int WHITE = 0xFF;
    static final int LARGE_VALUE = 99999;
    static final int SMALL_VALUE = -99999;
 

    static final int N = 7;//横方向のメッシュの数
    static final int M = 7;//縦方向のメッシュの数
    public static final int K = (N*M);//メッシュの総数
	
	public static final int K2 = 6;//交差特徴量の数

    static final int C = 10;//認識対象のカテゴリ数

  	//メッシュ特徴メソッド
	public static void MeshFeature(PgmImage pgm, double w[]) {
		
		//外接四角形
		int xmin = 1000000;
		int xmax = -1;
		int ymin = 1000000;
		int ymax = -1;
		
		for(int y=0; y<pgm.ys; y++){
			for(int x=0; x<pgm.xs; x++){
				if(pgm.img[x][y] == BLACK){
					if(x < xmin) xmin = x;
					if(y < ymin) ymin = y;
					if(x > xmax) xmax = x;
					if(y > ymax) ymax = y;
				}
			}
		}
		int wide = xmax-xmin+1;
		int hight = ymax-ymin+1;
		
		
		//メッシュ特徴量
        int[] b = new int[K];
        int[] s = new int[K];
        double x_len = (double)wide/N;
        double y_len = (double)hight/M;
        int k;
        
        for(int y=ymin; y<=ymax; y++){
            for(int x=xmin; x<=xmax; x++){
				k = (int)((y-ymin)/y_len)*N + (int)((x-xmin)/x_len);
                s[k] ++;
                if(pgm.img[x][y]==BLACK){
                    b[k] ++;  
                }
            }
        }

        for(k=0; k<K; k++){
			if(s[k]>0)
				w[k] = (double)b[k]/s[k];//各メッシュの黒画素の割合を求めてw[k]に代入
            else
				w[k] = 0.0;
        }
    }
	
	
	//交差特徴メソッド
    public static void CrossFeature(PgmImage pgm, int w[]) {
		
		//外接四角形
        int x, y;
        int xmin, xmax, ymin, ymax;
        int width, height;
        
        xmin = 1000000;
		xmax = -1;
		ymin = 1000000;
		ymax = -1;
		for(y=0; y<pgm.ys; y++){
			for(x=0; x<pgm.xs; x++){
				if(pgm.img[x][y] == BLACK){
					if(x < xmin) xmin = x;
					if(y < ymin) ymin = y;
					if(x > xmax) xmax = x;
					if(y > ymax) ymax = y;
				}
			}
		}
		width = xmax-xmin+1;
		height = ymax-ymin+1;
        
		
		//交差特徴量
        int stat;
        int k = 0;
        int Ny = 5;//水平方向を５等分
        int Nx = 3;//垂直方向を３等分
		
		//水平方向の交差特徴量
        for(int i=1; i<Ny; i++){
            y= ymin + i*height/Ny;
            w[k] = 0;
            stat = WHITE;
            for(x=xmin; x<=xmax; x++){
                if((stat==WHITE) && (pgm.img[x][y]==BLACK)){
                    stat = BLACK;
                    w[k]++;
                }
                else if(pgm.img[x][y]==WHITE){
                stat = WHITE;
                }
            }
            k++;
        }
		
		//垂直方向の交差特徴量
        for(int j=1; j<Nx; j++){
            x= xmin + j*width/Nx;
            w[k] = 0;
            stat = WHITE;
            for(y=ymin; y<=ymax; y++){
                if((stat==WHITE) && (pgm.img[x][y]==BLACK)){
                    stat = BLACK;
                    w[k]++;
                }
                else if(pgm.img[x][y]==WHITE){
                stat = WHITE;
                }
            }
            k++;
        }
		
    }
    
	//認識
	public static int Reco(PgmImage pgm) {  
		int result = -1;
		
		//メッシュ認識
        double[] w1 = new double[K];
		double pv1[][] = {//メッシュ数7*7の特徴ベクトル
			{0.06,0.19,0.29,0.26,0.25,0.24,0.14,0.20,0.19,0.05,0.00,0.00,0.08,0.35,0.32,0.06,0.00,0.00,0.00,0.01,0.39,0.36,0.01,0.00,0.00,0.00,0.02,0.39,0.36,0.00,0.00,0.00,0.00,0.08,0.33,0.35,0.03,0.01,0.00,0.03,0.17,0.21,0.16,0.26,0.25,0.25,0.28,0.21,0.05},
			{0.34,0.28,0.33,0.20,0.38,0.35,0.21,0.26,0.22,0.34,0.27,0.43,0.41,0.22,0.22,0.25,0.39,0.28,0.45,0.39,0.18,0.22,0.25,0.42,0.35,0.47,0.35,0.10,0.24,0.25,0.45,0.33,0.48,0.34,0.09,0.28,0.27,0.43,0.29,0.45,0.36,0.10,0.37,0.34,0.35,0.17,0.36,0.33,0.17},
			{0.15,0.34,0.35,0.35,0.32,0.22,0.12,0.21,0.07,0.01,0.01,0.10,0.17,0.19,0.03,0.01,0.00,0.01,0.15,0.21,0.15,0.00,0.00,0.00,0.10,0.28,0.16,0.02,0.00,0.01,0.13,0.32,0.13,0.01,0.00,0.03,0.25,0.31,0.07,0.00,0.00,0.00,0.39,0.51,0.40,0.38,0.38,0.37,0.30},
			{0.22,0.32,0.31,0.32,0.35,0.22,0.07,0.03,0.01,0.00,0.02,0.17,0.24,0.16,0.01,0.03,0.10,0.22,0.30,0.17,0.07,0.05,0.21,0.36,0.40,0.36,0.25,0.06,0.00,0.01,0.01,0.01,0.02,0.18,0.48,0.01,0.00,0.00,0.00,0.00,0.05,0.58,0.24,0.34,0.34,0.34,0.34,0.34,0.17},
			{0.01,0.02,0.10,0.24,0.18,0.06,0.02,0.05,0.16,0.22,0.30,0.18,0.04,0.02,0.26,0.29,0.19,0.30,0.23,0.13,0.11,0.19,0.17,0.14,0.29,0.25,0.14,0.12,0.06,0.05,0.06,0.23,0.18,0.07,0.04,0.01,0.01,0.03,0.20,0.13,0.04,0.01,0.00,0.00,0.03,0.19,0.13,0.05,0.01},
			{0.16,0.26,0.15,0.17,0.19,0.20,0.15,0.31,0.27,0.16,0.11,0.08,0.07,0.05,0.39,0.14,0.08,0.06,0.04,0.03,0.01,0.36,0.24,0.20,0.19,0.16,0.12,0.06,0.07,0.04,0.04,0.07,0.13,0.15,0.17,0.04,0.01,0.01,0.03,0.12,0.20,0.17,0.10,0.25,0.29,0.31,0.26,0.15,0.03},
			{0.01,0.06,0.20,0.26,0.26,0.21,0.13,0.06,0.26,0.16,0.03,0.01,0.00,0.02,0.24,0.22,0.06,0.03,0.02,0.01,0.01,0.41,0.24,0.22,0.23,0.22,0.18,0.11,0.44,0.09,0.05,0.05,0.07,0.12,0.34,0.40,0.03,0.00,0.01,0.03,0.14,0.32,0.25,0.33,0.31,0.31,0.32,0.25,0.06},
			{0.30,0.21,0.21,0.21,0.21,0.26,0.45,0.19,0.04,0.02,0.00,0.06,0.27,0.13,0.05,0.01,0.00,0.05,0.22,0.15,0.03,0.00,0.01,0.04,0.19,0.17,0.05,0.01,0.00,0.03,0.15,0.18,0.06,0.03,0.01,0.01,0.13,0.16,0.09,0.02,0.02,0.01,0.11,0.11,0.13,0.04,0.02,0.01,0.01},
			{0.38,0.40,0.36,0.37,0.35,0.27,0.15,0.35,0.20,0.08,0.10,0.17,0.27,0.26,0.17,0.33,0.34,0.28,0.28,0.23,0.15,0.10,0.25,0.37,0.36,0.31,0.18,0.05,0.26,0.19,0.13,0.12,0.20,0.24,0.19,0.30,0.16,0.09,0.03,0.15,0.15,0.31,0.26,0.36,0.40,0.39,0.38,0.27,0.21},
			{0.20,0.34,0.31,0.30,0.31,0.34,0.32,0.50,0.08,0.01,0.01,0.06,0.19,0.53,0.45,0.11,0.11,0.13,0.21,0.37,0.47,0.22,0.14,0.15,0.16,0.23,0.35,0.25,0.04,0.05,0.05,0.08,0.14,0.30,0.14,0.01,0.01,0.03,0.06,0.18,0.23,0.10,0.00,0.03,0.07,0.08,0.19,0.17,0.08}
		};
		
		MeshFeature(pgm, w1);
		
		
		double dmin = (double)LARGE_VALUE; 
		double dx; 
		double sum = 0;
		double[] meshArray = new double[C];//pv[][]とw[]の距離の配列
		
		for(int i=0; i<C; i++){
			sum=0.0;
			for(int j=0; j<K; j++){
				sum += (w1[j]-pv1[i][j]) * (w1[j]-pv1[i][j]);
			}
			
			dx = Math.sqrt(sum);
			meshArray[i] = dx;
		}
		


		//クロス認識
		int[] w2 = new int[K2]; //交差数特徴量
        int pv2[][] = { 
            {0, 2, 2, 2, 2, 2, 2},
			{0, 2, 2, 2, 2, 2, 2},
            {1, 1, 1, 1, 1, 1, 1},
            {1, 1, 1, 1, 1, 2, 1},
            {2, 2, 1, 1, 1, 3, 3},
			{2, 2, 1, 1, 1, 3, 3},
            {3, 2, 1, 1, 1, 3, 4},
            {3, 1, 1, 1, 1, 3, 4},
            {4, 2, 2, 2, 1, 2, 1},
            {4, 2, 2, 2, 1, 1, 1},
            {5, 1, 1, 1, 1, 3, 3},
			{5, 1, 1, 1, 1, 3, 3},
            {6, 1, 1, 2, 2, 3, 3},
            {6, 1, 2, 2, 2, 3, 3},
            {7, 2, 1, 1, 1, 1, 1},
            {7, 2, 1, 1, 1, 2, 2},
            {8, 2, 2, 2, 2, 3, 4},
            {8, 2, 1, 2, 2, 4, 4},
            {9, 2, 3, 1, 1, 3, 3},
            {9, 2, 2, 1, 1, 2, 3},
            {-1, 0, 0, 0, 0, 0, 0} 
        };

        CrossFeature(pgm, w2);
        
        int crossArray[] = new int[C];//w[]とpv[][]が一致しなかった数の配列
        int i =0;
		int num = 0;//w[]とpv[]が一致しなかった数
        while(pv2[i][0] >= 0) {
            for(int j=0; j<K2; j++){
                if(pv2[i][j+1] != w2[j]) { 
                    num++;
                }
            }
			if(i%2 != 0){//pv[i][]のiが奇数の時、
				crossArray[pv2[i-1][0]] += num;//ひとつ前のnumにたす
				num=0;//numの初期化
			}
			else{//pv[i][]のiが偶数の時
				crossArray[pv2[i][0]] = num;
			}
            i++;
        }


		double weight = 50;//重み meshArray[]の値はcrossArray[]に比べて非常に小さい
		for(int k=0; k<C; k++){
			//System.out.println("mesharray*weight, crossarray*weight2  "+meshArray[k]*weight+",   "+crossArray[k]*weight2);      
			if(meshArray[k]*weight+crossArray[k] < dmin){
				result = k;
				dmin = meshArray[k]*weight+crossArray[k];
			}
		}
		return result;
	}
}